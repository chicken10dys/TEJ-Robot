#pragma config(Sensor, dgtl5,  LimSwitch,      sensorDigitalIn)
#pragma config(Sensor, dgtl12, RelayN,         sensorDigitalOut)
#pragma config(Motor,  port1,           FR,            tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FL,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Calculates which value from a pair of values is the minimum or maximum of the two
#define MIN(i, j) (((i) < (j)) ? (i) : (j))
#define MAX(i, j) (((i) > (j)) ? (i) : (j))

//Stores the dead zone used for the controller
const short DEAD_ZONE = 5;

//Represents the max value for a motor
const short MAX_DIR = 127;
const short MIN_DIR = -127;

//Represents the high and low states of digital I/O devices
const int HIGH = 1;
const int LOW = 0;

//Stores the state of the program
bool running = true;

//Stores the movement value for the left and right motors
short dirx = 0;
short diry = 0;
short Ls = 0;
short Rs = 0;

//State of the relay
bool relayState = false;

bool relayBtnState = false;
bool prevRelayBtnState = false;

bool needNewRelayInput = false;

void MoveRobot()
{
	//Gets the direction of the vertical and horizontal axis of the left joystick
	dirx = vexRT(Ch4);
	diry = vexRT(Ch3);


	if(-DEAD_ZONE <= dirx && dirx <= DEAD_ZONE && -DEAD_ZONE <= diry && diry <= DEAD_ZONE)
	{
		//Sets the values of the motors to 0 if the stick is within the range of the dead zone
		Rs = 0;
		Ls = 0;
	}
	else if (dirx == 0 && diry == MAX_DIR)
	{
		Rs = MAX_DIR;
		Ls = MAX_DIR;
	}
	else if (dirx == MIN_DIR && diry == 0)// add deadzone
	{
		Rs = MAX_DIR;
		Ls = MIN_DIR;
	}
	else if (dirx == 0 && diry == MIN_DIR)
	{
		Rs = MIN_DIR;
		Ls = MIN_DIR;
	}
	else if (dirx == MAX_DIR && diry == 0)
	{
		Rs = MIN_DIR;
		Ls = MAX_DIR;
	}
	else
	{
		//Q1
		if (diry > 0 && dirx > 0){
			Rs = MAX(dirx, diry);
			Ls = diry - dirx;
		}
		//Q2
		if (diry > 0 && dirx < 0){
			Rs = diry + dirx;
			Ls = MAX(dirx, diry);
		}
		//Q3
		if (diry < 0 && dirx < 0){
			Ls = MIN(dirx, diry);
			Rs = diry - dirx;
		}
		//Q4
		if (diry < 0 && dirx > 0){
			//
			Rs = MIN(dirx, diry);
			Ls = dirx + diry;
		}
	}

	motor[FL] = Ls;
	motor[BL] = Ls;
	motor[FR] = Rs;
	motor[BR] = Rs;
}

task main()
{
	//Loops until the program is not running any more
	while (running)
	{
		//Moves the robot using the joystick
		MoveRobot();

		prevRelayBtnState = relayBtnState;
		relayBtnState = vexRT(Btn8L);


		if(relayState == false)
		{
			if(relayBtnState == true && needNewRelayInput == false)
			{
				relayState = true;
			}
			else if(needNewRelayInput == true && (relayBtnState == true && prevRelayBtnState == false))
			{
				relayState = true;
			}
		}
		else
		{
			if(SensorValue[LimSwitch] == LOW)
			{
				relayState = false;
				needNewRelayInput = true;
			}
			else if(relayBtnState == false)
			{
				relayState = false;
			}
		}


		if(relayState == true)
		{
			SensorValue[RelayN] = LOW;
		}
		else
		{
			SensorValue[RelayN] = HIGH;
		}

		//Exits the program if both of the U sholder buttons are pressed
		if (vexRT(Btn5U) == true && vexRT(Btn6U) == true)
		{
			running = false;
		}
	}
}
