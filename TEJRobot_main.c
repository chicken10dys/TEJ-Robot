#pragma config(Sensor, dgtl2,  Relay,          sensorDigitalOut)
#pragma config(Sensor, dgtl6,  RelayT,         sensorDigitalOut)
#pragma config(Sensor, dgtl12, RelayN,         sensorDigitalOut)
#pragma config(Motor,  port1,           FR,            tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FL,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MIN(i, j) (((i) < (j)) ? (i) : (j))
#define MAX(i, j) (((i) > (j)) ? (i) : (j))

//Stores the state of the program
bool running = true;

bool isRelayOn = false;

//Stores the movement value for the left and right motors
short dirx = 0;
short diry = 0;
short Ls = 0;
short Rs = 0;

//Represents the max value for a motor
short maxDir = 127;
short minDir = -127;

//Stores the dead zone used for the controller
short deadZn = 5;

task main()
{
		SensorValue[RelayN] = 1;

    //Loops until the program is not running any more
    while (running)
    {

    	dirx = vexRT(Ch4);
    	diry = vexRT(Ch3);

    	if(-deadZn <= dirx && dirx <= deadZn && -deadZn <= diry && diry <= deadZn)
    	{
    		Rs = 0;
    		Ls = 0;
    	}
    	if (dirx == 0 && diry == maxDir)
    	{
    		Rs = maxDir;
    		Ls = maxDir;
    	}
    	else if (dirx == minDir && diry == 0)// add deadzone
    	{
    		Rs = maxDir;
    		Ls = minDir;
    	}
    	else if (dirx == 0 && diry == minDir)
    	{
    		Rs = minDir;
    		Ls = minDir;
    	}
    	else if (dirx == maxDir && diry == 0)
    	{
    		Rs = minDir;
    		Ls = maxDir;
    	}
    	else
    	{
    		//Q1
	    	if (diry > 0 && dirx > 0){
	    		Rs = MAX(dirx, diry);
	    		Ls = diry - dirx;
	    	}
	    	//Q2
	    	if (diry > 0 && dirx < 0){
	    		Rs = diry + dirx;
	    		Ls = MAX(dirx, diry);
	    	}
	    	//Q3
	    	if (diry < 0 && dirx < 0){
	    		Ls = MIN(dirx, diry);
	    		Rs = diry - dirx;
	    	}
	    	//Q4
	    	if (diry < 0 && dirx > 0){
	    		//
	    		Rs = MIN(dirx, diry);
	    		Ls = dirx + diry;
	    	}
    	}

    	motor[FL] = Ls;
    	motor[BL] = Ls;
    	motor[FR] = Rs;
    	motor[BR] = Rs;

    //////////////////////////////////

      /*if(SensorValue(Btn8R) == true && isRelayOn == false)
      {
      	isRelayOn = true;
      	SensorValue[RelayN] = 0;
      }
      else if (SensorValue(Btn8R) == false && isRelayOn == true)
      {
      	SensorValue[RelayN] = 1;
      	isRelayOn = false;
      }*/

      if(vexRT(Btn8L) == true)
      {
      	SensorValue[RelayN] = 0;
      }
      
      //SensorValue[RelayT] = 1;
      //wait1Msec(1000);
      //SensorValue[RelayT] = 0;
      //wait1Msec(1000);


      //Exits the program if both of the U sholder buttons are pressed
      if (vexRT(Btn5U) == true && vexRT(Btn6U) == true)
      {
          running = false;
      }
    }
}